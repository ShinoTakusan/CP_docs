# ABC

## ABC049

---

**A 題名**：ただ題名がいい

## ABC064

---

[**D 典型題　stack**](./064.md)

## ABC079

---

[**D 最短経路問題、ワ―シャルフロイド法**](079.md)

## ABC084

---

**C 全探索**：ただ単にシミュレートすればよい。

[**D 素数判定、累積和**](084.md)

## ABC085

---

**D シミュレーション**：刀が壊れるという状況はそこまで深く考える必要はない。たった一度しか使えない攻撃力biの刀、何度も触れる攻撃力aiの刀というように分けて考えるととても簡単である。

## ABC094

---

**D　数学**：普通に考えて２つの数に対して組み合わせを計算して全探索するのは無理である。組み合わせの性質を考察する問題。

## ABC113

---

**C 二分探索**：二分探索を行うことで計算量を減らすことができる。<algorithm>にある*std::lower_bond*で簡単に実装でき、目標のイテレータを受け取ることができる。目標の出現場所を数値として扱いたい場合は、std::distanceで簡単に求めることができる。

## ABC127

---

**D_prime ランレングス圧縮の利用**：愚直にcをb個用意するのではなく、pairでまとめている。

## ABC130

---

**D 尺取り法**：ある条件を満たす区間を探すのが得意なアルゴリズム。

## ABC134

---

**D 思考**：緑diffによくある考えれば$$O(n)$$ぐらいで終わるやつである。今回のポイントとしては、倍数に注目するである。iの倍数はi以上でないと出てこないのでi以上のiの倍数についてみればよく$$O(\frac{N}{1} + \frac{N}{2} + \frac{N}{3} + ... + \frac{N}{N})$$となる。これは$$O(NlogN)$$となる。計算量が理解しにくい場合は、これを連続したものと考えればよい。つまり$$O(N\int_{1}^{N} \frac{1}{x} dx)$$となり$$O(NlogN)$$となる。0,1しか扱わないときはXORを使うと簡潔に書くことができる。問題文では*成り立たない場合に-1と出力せよ*とあるが、そのときがない場合もあるので注意して考察せよ。

## ABC138

---

**D DFS、累積和**：愚直にグラフを実装し、シミュレートしては計算量が増えるので駄目。あらかじめ、部分木の頂点に加算し、根から累積和をとるようにすると計算量が抑えられる。

## ABC142

---

**D 素因数分解、最大公約数**：2数の約数はそれらの最大公約数の約数を列挙すればよい。約数列挙、素因数分解は$$\sqrt{N}$$で可能である。

## ABC147

---

**C bit全探索**：この手の真偽を調べる時にはbit全探索が有効である。また入力の大きさからもそのようなことが分かる。具体的には*誰が正しいことを言っているのか*について全探索を行う。仮定があっている場合は、その時の立っているbitの数が正直者の数であり、その最大値を探索すればよい。

**D XOR**：XORは桁上がりのない和とみることができ、各桁の演算が独立しているので桁に注目するといいことがある。今回は、各桁の0,1の個数の組み合わせ×桁、それらの和が答えである。こういう時は集合を意識するとわかりやすい。

参考：https://outline.hatenadiary.jp/entry/2019/12/17/021530

## ABC151

---

**D BFS,典型題**：典型的なBFSの問題である。BFSは距離に対する重みがないときの最短経路問題を解くことができる。今回は最長経路なので、各地点から最も遠い場所をBFSすればよい。

## ABC153

---

[**計算**](153.md)
[**dp、ナップサック問題**](153.md)

### ABC156

---

[**フェルマーの小定理、数学**](156.md)

## ABC161

---

[**D 特殊、queue、BFS、全列挙**](161.md)

## ABC164

---

**D MOD,典型**：このような問題はMODの性質を上手に利用することで解くことができる。ここでTk(右からk番目までの数字からなる整数)を考える。（ex: s = 1817181712114、j = 10のときtj = 2114）である。すると区間[i,j]から得られる整数は次のように表現される。(Ti-Tj)/10^(n-|s|)である。この整数を2019で割ったときの余りが0になれば、正解である。ここで合同式の性質を利用する。任意のa,b,c,p（a,pは互いに素）において次のような関係が成り立つ。ab mod p = ac mod p 。今回はこの性質を利用する。10と2019は互いに素であるため、上で議論した(Ti-Tj)/10^(n-|s|)の余りは(Ti-Tj)の余りと等しくなる。以上の議論よりTi mod 2019 = Tj mod 2019　である組の個数が本題の答えである。実際の実装としては、すべてのTiに対する余りをとり、同じあまりである個数を数える。各余りの個数から２つ選ぶ組み合わせを計算し(Ti mod 2019 = Tj mod 2019である組と同じこと)、その和が答えである。 同じような条件が成り立つときにこの性質が使えるので割と典型題らしい。合同式の性質をうまく利用したいところである。

参考：https://www.youtube.com/watch?v=Ra0y0EZ24ZM&t=876s